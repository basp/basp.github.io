<!DOCTYPE html>
<html lang="en-us">
    <head>
         
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>implementing a tiny float</title>
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: hotpink;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://basp.github.io//css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.31.1" />
        
        
        
    </head>

    
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

    <body>
         
        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">implementing a tiny float</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/projects/">Projects</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:me@example.com"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/basp/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://twitter.com/meticulous/"><i class="fa fa-twitter"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/posts/implementing-a-tiny-float/">implementing a tiny float</a></h4>
    <h5>February 21, 2018</h5>
    

</div>


    <br> <div class="text-justify">

<p>Recently I became interested in the IEEE standard of floating punt numbers for various reasons and as always I figured the best way to learn about something is to (try and) create it myself. So that&rsquo;s what I did.</p>

<p>This post will walk you through implementing a IEEE compatible software float value of exactly 8 bits long. We&rsquo;ll look at some of the challenges and hopefully learn a bit more about what <strong>floating point</strong> values really are.</p>

<p><a href="http://www.toves.org/books/float/">Carl Burch&rsquo;s book</a> helped me a lot while trying to figuring out this stuff. Also, if you&rsquo;re interested in these kinds of things then you might find <a href="https://fgiesen.wordpress.com/2018/02/19/reading-bits-in-far-too-many-ways-part-1/">the ryg blog</a> interesting as well.</p>

<p>To keep things simple this post is gonna focus on a (mostly useless) implementation of the <strong>IEEE</strong> standard float in exactly eight bits (i.e. a <code>byte</code>). The reasons for this are simple:</p>

<ol>
<li>The algorithms and conceptual ways of thinking are valid from <code>8</code> to <code>n</code> bits.</li>
<li>Working with bits (and how they are stored) can be confusing and it&rsquo;s <strong>a lot</strong> easier to debug, inspect and control when working with a small register size.</li>
</ol>

<h2 id="the-data-structure">the data structure</h2>

<p>Here&rsquo;s a crude picture that somewhat resembles how these things are layed out:</p>

<pre><code>MSB                           LSB   for both E and M
+---------------+-----------+---+
|        E      |      M    | S |   layout (when enumerated)
+---------------+-----------+---+
         4             3      1     length in bits
</code></pre>

<p>We&rsquo;re gonna define our tiny float as a <code>Float8</code> to make it clear we&rsquo;re dealing with an 8 bit float. Our <strong>storage</strong> will be a <code>byte</code> and this <code>byte</code> will hold all the information we need to convert that sequence of bits into a floating point value.</p>

<pre><code>struct Float8
{
    byte s;
}
</code></pre>

<p>Excellent. Now believe it or not, everything we need to know about our float will be <em>packed</em> into that little <code>s</code> byte. As far as our data structure is going, this will be mostly it. It&rsquo;s really nothing more than a jacket to attach things to (and to protect our precious <code>s</code> variable).</p>

<h2 id="basic-bit-manipulation">basic bit manipulation</h2>

<p>Before we should consider how we will store everything in our byte. There&rsquo;s three major components to every floating point number and it makes sense to consider the general formula of a floating point first:</p>

<p><code>sign * mantissa * (2 ** exp)</code></p>

<p>Now this is not exactly how it&rsquo;s implemented but conceptually that is what&rsquo;s happening inside and it is useful to keep that in mind. From that formula alone we can already identify the three components clearly:</p>

<ul>
<li><strong>sign</strong> is one bit wide and is either <code>0</code> or <code>1</code> where <code>1</code> flags a negative number.</li>
<li><strong>mantissa</strong> is an integer of three bits that determines the accuracy of our number.</li>
<li><strong>exponent</strong> is a power of two that determines the range (or scale) of our number.</li>
</ul>

<p>Now clearly if we store sign as a <code>0</code> or <code>1</code> bit we can&rsquo;t exactly multiply it like in the formula above but that will not be a problem. Actually, we could probably solve this with some bitmagic. But this is intended to be an educational implementation and not so much a reference one so we will just work with what we got.</p>

<h2 id="basic-operations">basic operations</h2>

<p>The first thing we need is to be able to access the individual components of our storage (<code>s</code>) byte. Because they can be implemented in a very straightforward way I&rsquo;m just gonna lay them out in full at once:</p>

<pre><code>static byte SetMantissa(byte v, byte m) =&gt; (byte)(v &amp; 0b00011111 | (m &lt;&lt; 5));

static byte GetMantissa(byte v) =&gt; (byte)((v &amp; 0b11100000) &gt;&gt; 5);

static byte SetExponent(byte v, byte e) =&gt; (byte)(v &amp; 0b11100001 | (e &lt;&lt; 1));

static byte GetExponent(byte v) =&gt; (byte)((v &amp; 0b00011110) &gt;&gt; 1);

static byte SetSign(byte v, byte s) =&gt; (byte)(v &amp; 0b11111110 | s);

static byte GetSign(byte v) =&gt; (byte)(v &amp; 0b00000001);
</code></pre>

<p>As one will notice I have (deliberately) done them very crude with binary literals. I really like the bitmasks in this case because they clearly show the areas of the byte that we&rsquo;re interested in and they really help to extrapolate the algorithms we will develop into much bigger sequences of bits. They are good for educational purposes but there&rsquo;s a whole science into constructing nice bitmaks that I will get back to in a later post.</p>

<p>Back to our main problem, bascially those <code>Get</code> and <code>Set</code> members are very similar. The setters:</p>

<ol>
<li>Zero out the original value at selected bits by using a <em>negative</em> mask and the binary <strong>and</strong> operation.</li>
<li>Add in the new value by first shifting it into the appropriate position and then using an <strong>or</strong> operation to combine it with the masked value.</li>
</ol>

<p>And the getters:</p>

<ol>
<li>Zero out anything they don&rsquo;t need by using a <em>positive</em> mask and the binary <strong>and</strong> operation.</li>
<li>Shift the result to the right to <em>normalize</em> it into an integer and then return the result.</li>
</ol>

<p>Now that we have a way to access parts of our storage using getters and setters we can make our struct a bit more useful as well.</p>

<h2 id="essential-members">essential members</h2>

<p>It would be very useful if we could just access the parts of our <code>s</code> byte by using properties. And now that we have our basic operations we can implement that easily. We just need to add a little bit of fluff to our <code>Float8</code> struct.</p>

<h3 id="about-bias">about bias</h3>

<p>Also, we need to talk about <strong>bias</strong> before we continue. If we look at our exponent it&rsquo;s just four bits. We need negative exponents as well otherwise we would <strong>not be able</strong> to represent a value smaller than one in the first place. But how can we represent such negative exponents if we only have four bits to work with?</p>

<p>We could use a sign bit of course but that would be a huge sacrifice on just a four bit value. The <strong>IEEE</strong> solution is actually to introduce a so called <em>bias</em> that basically says: every exponent is actually 7 less than the exponent you get from reading the actual value from the byte.</p>

<p>This sounds confusing so let&rsquo;s start by looking at the code for the <code>Exponent</code> property. Note that we&rsquo;re using <code>sbyte</code> in the property signature and also when casting it for readers. The exponent should be able to be negative so we need a <strong>signed</strong> <code>sbyte</code> instead of a normal <code>byte</code> (which is unsigned).</p>

<pre><code>public sbyte Exponent
{
    get =&gt; (sbyte)(GetExponent(this.s) - bias);
    set =&gt; this.s = SetExponent(this.s, (byte)(value + bias));
}
</code></pre>

<p>When we <strong>set</strong> this value we <em>secretly</em> add a value of <code>bias</code> to it. When we read the value, we subtract the value of <code>bias</code> instead. This allows us to store values from <code>0..n</code> but also <em>interpret</em> them as negative. Although we&rsquo;re limited by a <strong>constant</strong> bias that is determined by the size of our exponent register.</p>

<p>When we have an exponent register of size <code>n</code> bits we want a <code>bias</code> value that is the maximum number that we can represent in <code>n - 1</code> bits. So if we have four bits in like in this case we need the max number that we can respresent with only three bits and that is <code>(1 * 2**2) + (1 * 2**1) + (1 * 2**0) = 4 + 2 + 1 = 7</code>.</p>

<p>So that&rsquo;s why we have a <code>bias</code> value of <code>7</code> in this case:</p>

<pre><code>const byte bias = 7;
</code></pre>

<p>And that goes right inside our <code>Float8</code> struct.</p>

<h2 id="birth-of-a-tiny-float">birth of a tiny float</h2>

<p>By now we have seen some examples and so it&rsquo;s time to put things together. To be honest, the only thing to note about the code below is the way <code>Exponent</code> is handled using the <code>bias</code> value. The rest is straight forward bit masking and simple operations using the methods we declared earlier.</p>

<pre><code>struct Float8
{
    byte s;

    const byte bias = 7;

    public byte Sign
    {
        get =&gt; GetSign(this.s);
        set =&gt; this.s = SetSign(this.s, value);
    }

    public sbyte Exponent
    {
        get =&gt; (sbyte)(GetExponent(this.s) - bias);
        set =&gt; this.s = SetExponent(this.s, (byte)(value + bias));
    }

    public byte Mantissa
    {
        get =&gt; GetMantissa(this.s);
        set =&gt; this.s = SetMantissa(this.s, value);
    }

    static string ToBitString(byte v) =&gt; Convert.ToString(v, 2);

    static byte SetMantissa(byte v, byte m) =&gt; (byte)(v &amp; 0b00011111 | (m &lt;&lt; 5));

    static byte GetMantissa(byte v) =&gt; (byte)((v &amp; 0b11100000) &gt;&gt; 5);

    static byte SetExponent(byte v, byte e) =&gt; (byte)(v &amp; 0b11100001 | (e &lt;&lt; 1));

    static byte GetExponent(byte v) =&gt; (byte)((v &amp; 0b00011110) &gt;&gt; 1);

    static byte SetSign(byte v, byte s) =&gt; (byte)(v &amp; 0b11111110 | s);

    static byte GetSign(byte v) =&gt; (byte)(v &amp; 0b00000001);
}
</code></pre>

<p>Note that <code>ToBitString</code> uses <code>Convert</code> and a base of two to get a reasonable bit string from our <code>s</code> storage variable. It&rsquo;s mostly for debugging and trying to make sense of the numbers even though it&rsquo;s actually a pretty poor representation.</p>

<p>And since this is already much longer than I planned I will keep the rest of our tiny float structure for a next post.</p>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>
       
    </body>

</html>


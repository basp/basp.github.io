<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>drawing arrows in 2d</title>
    <link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:500|Raleway" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/arduino-light.min.css">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<root><section><h1>drawing arrows in 2d</h1><p>An interesting problem is how to draw arrows in two dimensions. While writing this book I was dealing with this problem and while I was initially struggling to understand all the math behind it, everything sort of clicked when I started thinking about it from a linear algebra perspective.</p><p>For the rest of this chapter we are going to assume we are working in two dimensions but this will work in <mathjax>$n$</mathjax> dimensions as well of course. Some knowledge of vector and matrix operations is assumed.</p><h3>the problem</h3><p>Given two points <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>, draw an arrow between those points with an arrow head of specified length (specified in units) and <em>narrowness</em> which is specified in radians.</p><p>The length of our arrowhead <mathjax>$L_h$</mathjax> is a known constant. As well as the narrowness of our arrowhead <mathjax>$\theta$</mathjax>. We can treat these two values as given.</p><p>In some calculations we refer to the <em>origin</em> point which we call <mathjax>$P_0$</mathjax>. We can treat this as a given as well. For this example it will just be the point <mathjax>$\left(0,0\right)$</mathjax> but it does not have to be.</p><h3>the solution</h3><p>We want to express the length of our arrow head <mathjax>$L_h$</mathjax> in terms of the length of our base line <mathjax>$P_1$</mathjax> to <mathjax>$P_2$</mathjax> so that<br/><mathjax>$$L_h = t(P_2 - P_1)$$</mathjax></p><p>Since we will be dealing with <mathjax>$P_2 - P_1$</mathjax> <em>a lot</em> we will give this vector the name <mathjax>$\vec{A}$</mathjax> so that</p><p><mathjax>$$\begin{align}
\vec{A} = P_2 - P_1
\end{align}$$</mathjax></p><p>and that we also have</p><p><mathjax>$$L_h = t\vec{A}$$</mathjax></p><p>since we have <mathjax>$\vec{A} = P_2 - P_1$</mathjax> and <mathjax>$t\vec{A}$</mathjax> just means scaling the vector <mathjax>$\vec{A}$</mathjax> by some amount of <mathjax>$t$</mathjax>.</p><p>Now, in order to draw our arrowhead we are going to calculate points <mathjax>$P_3$</mathjax> and <mathjax>$P_4$</mathjax> which lie at the tips of the arrowhead except they will be positioned relative to the origin and not relative to <mathjax>$P_2$</mathjax>. The reason for this is that it is much easier to work with values relative to the origin and translating them to their final position will be quite easy as we will see shortly.</p><p>We start by calling the angle of the arrowhead edges and the arrow line <mathjax>$\theta$</mathjax>. This angle effectively controls the narrowness of our arrow. A small value will give a narrow arrowhead and a large value will give a wide arrowhead. Unless you are drawing really funky arrows you should limit your angles to a value of <mathjax>$\theta$</mathjax> where <mathjax>$0\le\theta\le\frac{pi}{2}$</mathjax> (i.e. between <mathjax>$0^\circ$</mathjax> and <mathjax>$90^\circ$</mathjax>).</p><p>To calculate <mathjax>$P_3$</mathjax> and <mathjax>$P_4$</mathjax> we first calculate <mathjax>$P_t$</mathjax> which we get by scaling the vector <mathjax>$\vec{A}$</mathjax> by <mathjax>$t$</mathjax> and then adding that vector to the origin point <mathjax>$P_0$</mathjax>.</p><p><mathjax>$$P_t = P_0 + t\vec{A} = P_0 + t(P2 - P1)$$</mathjax></p><p>Now we rotate <mathjax>$P_t$</mathjax> by <mathjax>$\theta$</mathjax> and <mathjax>$-\theta$</mathjax> around the origin to get <mathjax>$P_3$</mathjax> and <mathjax>$P_4$</mathjax>. An easy way to rotate them is by using the well known <em>rotation matrix</em> which for any angle <mathjax>$\alpha$</mathjax> defines a counter-clockwise rotation matrix <mathjax>$R_{\alpha}$</mathjax> so that</p><p><mathjax>$$R_{\alpha} = \begin{bmatrix}
              \cos{\alpha} &amp; -\sin{\alpha}\\
              \sin{\alpha} &amp; \cos{\alpha}
              \end{bmatrix}$$</mathjax></p><p>And now we can use that in order to define <mathjax>$P_3$</mathjax> and <mathjax>$P_4$</mathjax>:</p><p><mathjax>$$\begin{align}
P_3 &amp;= {P_t}{R_{\theta}}\\
P_4 &amp;= {P_t}{R_{-\theta}}
\end{align}$$</mathjax></p><p>The only thing left is to calculate <mathjax>$t$</mathjax>, the scaling factor for vector <mathjax>$\vec{A}$</mathjax>. If we think about it, if <mathjax>$t$</mathjax> is a scaling then we just need to calculate the ratio between the length of our arrowhead <mathjax>$L_h$</mathjax> and the <em>norm</em> (or length) of <mathjax>$\vec{A}$</mathjax>:</p><p><mathjax>$$t = \frac{L_h}{\lVert\vec{A}\rVert}$$</mathjax></p><p>where the norm of <mathjax>$\vec{A}$</mathjax> is defined as</p><p><mathjax>$$\lVert\vec{A}\rVert = \sqrt{\vec{A}\cdot\vec{A}}$$</mathjax></p><p>If we expand that out we can write out the full definition for <mathjax>$P_3$</mathjax>:</p><p><mathjax>$$P_3 = P(\theta) =
    t\vec{A}
    \begin{bmatrix}
    \cos{\theta} &amp; -{\sin{\theta}}\\
    \sin{\theta} &amp; \cos{\theta}
    \end{bmatrix}$$</mathjax></p><p>where</p><p><mathjax>$$t = \frac{L_h}{\sqrt{\vec{A}\cdot\vec{A}}}$$</mathjax></p><p>And the definition for <mathjax>$P_4$</mathjax> is exactly the same except we will use <mathjax>$-{\theta}$</mathjax> in the rotation matrix instead of <mathjax>$\theta$</mathjax> so that we get <mathjax>$P_4 = P(-{\theta})$</mathjax>.</p><p>As part of the final step we define two vectors going from points <mathjax>$P_3$</mathjax> and <mathjax>$P_4$</mathjax> to the origin point <mathjax>$P_0$</mathjax> as follows:</p><p><mathjax>$$\vec{B} = P_0 - P_3\\
\vec{C} = P_0 - P_4$$</mathjax></p><p>Note that these vectors run in the opposite direction to our original vector <mathjax>$P_2 - P_1$</mathjax>. This is because we want to add <mathjax>$\vec{B}$</mathjax> and <mathjax>$\vec{C}$</mathjax> to the point <mathjax>$P_2$</mathjax> in order to <em>translate</em> points <mathjax>$P_3$</mathjax> and <mathjax>$P_4$</mathjax> from their position relative to the origin to a position relative to <mathjax>$P_2$</mathjax>.</p><p><mathjax>$$P_5 = P_2 + \vec{B}\\
P_6 = P_2 + \vec{C}$$</mathjax></p><p>And with that, all the pieces are in place. If you now draw lines between <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>, <mathjax>$P_5$</mathjax> and <mathjax>$P_2$</mathjax> and <mathjax>$P_6$</mathjax> and <mathjax>$P_2$</mathjax> you get a pretty decent looking arrow (if you chose appropriate values for <mathjax>$L_h$</mathjax> and <mathjax>$\theta$</mathjax> that is).</p><aside><p>Although it is a bit risky, you can treat any point <mathjax>$P$</mathjax> as a vector by considering that there is always a line from the origin <mathjax>$P_0$</mathjax> to <mathjax>$P$</mathjax>. This also means that you typically can get away by using the same data structure for points and vectors. Almost always, a vector structure is chosen to represent points in a system as well since the operations associated with a vector are basically a superset of the operations associated with a point.</p><p>However, there is something to be said for keeping points and vectors separate since it is typically very easy to convert between them anyway and it from a math perspective the operations are much more well defined.</p></aside><h2>code</h2><h3>foundations</h3><p>To do all the things from the theory above in a nice way in code, we need to setup the primitives of a two-dimensional graphics library. In order to make sure we adhere to the math we will have real distinction between points and vectors and the kind of operations you can do with them.</p><p>We will have a dependency on the <code>math/matrix</code> and <code>math//array</code> libraries but that is just because I was too lazy to include all the matrix operations myself. It is really just tedious and not very relevant for this particular problem anyway since it is so extensively explained and used throughout the rest of this book anyway.</p><p>However, I did want to stay true to the math above, as well as making a point (no pun intended) of being really explicit about points and vectors. So I did choose to setup data structures for them, instead of just using the <code>math/matrix</code> library.</p><pre>(struct pt (x y) #:transparent)<br/>(struct vec (dx dy) #:transparent)</pre><p>You can see that the structures are basically equivalent when you just consider the data. Both contain two numerical components. However, the distinction is in the fact that a <code>vec</code> specifies a direction while a <code>pt</code> is an anchor in space (a plane in this case). I marked them transparent because that is just super useful in interactive use and I see no reason to keep them opaque.</p><p>Since we are dealing with vector space there is only a few operations we have at our disposal.</p><p>In fact, there is <strong>only three operations</strong> we can do:</p><ol><li>Subtract two points to get a vector</li><li>Add a vector to a point to get a new point</li><li>Scale a vector by a constant</li></ol><h4>subtract two points to get a vector</h4><p>We will start with subtracting two points in order to get a new vector. In the code below, the point <code>p</code> is the end point of the vector and <code>q</code> is the starting point.</p><pre>(define (pt- p q)<br/>    (let ([dx (- (pt-x p) (pt-x q))]<br/>          [dy (- (pt-y p) (pt-y q))])<br/>        (vec dx dy)))</pre><p>The <code>dx</code> and <code>dy</code> components are calculated by subtracting the <code>x</code> and <code>y</code> components of points <code>p</code> and <code>q</code>.</p><p>If you are at point <code>p</code> and you walk in a straight line to point <code>q</code> you will get the vector <code>q - p</code>. This might look a bit strange considering the algorithm above but considering that <code>pt-</code> should be called with the end point first it should make sense.</p><p>Note that this <em>operator</em> <code>pt-</code> is a little bit funky since its result is of a different type than its inputs. It returns a <code>vec</code> as the function of two <code>pt</code> instances. We will see more of these funky operators during the rest of this chapter.</p><h4>add a vector to a point to get a new point</h4><p>Next up is adding a vector to a point. This is defined by the <code>pt+</code> operator.</p><pre>(define (pt+ p v)<br/>    (let ([x (+ (pt-x p) (vec-dx v))]<br/>          [y (+ (pt-y p) (vec-dy v))])<br/>        (pt x y)))</pre><p>This is just adding the components of a vector to the components of a point in order to get to a new point.</p><h4>scale a vector by a constant</h4><p>And finally, we have the vector scale operation where we scale a vector by a constant. This is defined by the <code>vec*</code> operator.</p><pre>(define (vec* c v)<br/>    (let ([dx (* c (vec-dx v))]<br/>          [dy (* c (vec-dy v))])<br/>        (vec dx dy)))</pre><p>This operation can make any vector longer or shorter and even flip its direction if we scale it with a negative value.</p><h4>dot product</h4><p>However, there is actually quite a few more things we can do when dealing with vectors on a higher level. For instance, calculating the <em>dot product</em> is part of our algorithm so we should probably define that.</p><pre>(define (vec-dot u v)<br/>    (let ([dx (* (vec-dx u) (vec-dx v))]<br/>          [dy (* (vec-dy u) (vec-dy v))])<br/>        (+ dx dy)))</pre><p>This multiplies all the components of one vector with all the components of another vector and sums them up resulting in a <em>scalar</em> (single value) number. We will use the <code>vec-dot</code> operator as a convenience when calculating the <em>norm</em> (length) of a vector using the Pythagorean theorem.</p><h4>negation</h4><p>Conveniently, we can also turn a vector in the exact opposite direction by <em>negating</em> it. This is equivalent to placing minus signs in front of the components.</p><pre>(define (vec-neg v)<br/>    (let ([dx (- (vec-dx v))]<br/>          [dy (- (vec-dy v))])<br/>        (vec dx dy)))</pre><h4>norm</h4><p>Calculating the norm is straightforward now that we already defined the dot product. The norm is just calculating the length of a vector using the Pythogarean theorem.</p><pre>(define (vec-norm v) (sqrt (vec-dot v v)))</pre><h4>utilities</h4><p>For working interactively, it is often useful to convert between vectors and points. However, I would advise against using these in non-interactive definitions.</p><pre>(define (vec-&gt;pt v) (pt (vec-dx v) (vec-dy v)))<br/>(define (pt-&gt;vec p) (vec (pt-x p) (pt-y p)))</pre><p>Since I tend to think in degrees instead of radians I also like to have two functions to help me convert between them.</p><pre>(define (deg-&gt;rad n) (* n (/ (* 2 pi) 360)))<br/>(define (rad-&gt;deg n) (* n (/ 360 (* 2 pi))))</pre><h4>transform</h4><p>The final piece will be the <code>vec-transform</code> operator which performs a vector-matrix multiplication. This is the only function that requires the <code>math/matrix</code> and <code>math/array</code> dependencies.</p><pre>(define (vec-transform v m)<br/>    (let* ([n (row-matrix [(vec-dx v) (vec-dy v) 1])]<br/>           [o (matrix* n m)])<br/>        (vec [array-ref o (vector 0 0)] [array-ref o (vector 0 1)])))</pre><p>In order to complete the basics of our graphics library we also need a way to create the three primitive transformation matrices for translation, scaling and rotation.</p><pre><p>(define (translation-matrix dx dy)<br/>    (matrix [[1 0 0] [0 1 0] [dx dy 1]]))</p><p>(define (scale-matrix sx sy)<br/>    (matrix [[sx 0 0] [0 sy 0] [0 0 1]]))</p><p>(define (rotation-matrix t)<br/>    (matrix [[(cos t) (sin t) 0]<br/>            [(- (sin t)) (cos t) 0]<br/>            [0 0 1]]))</p></pre><p>We have defined them with very explicit names in order to make it clear what these things mean when we eventually look back at this code in the future. However, the names are a little bit too unwieldy to use comfortably so we might as well give them a few shorthands.</p><pre>(define (tab a b) (translation-matrix a b))<br/>(define (sab a b) (scale-matrix a b))<br/>(define (rt t) (rotation-matrix t))</pre><p>This will help with interactive use and might even make our algorithms more readable versus using the really verbose names.</p><h3>algorithm</h3></section></root>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
</body>
</html>
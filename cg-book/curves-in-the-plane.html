<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Curves in the plane</title>
    <link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:500|Raleway" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/arduino-light.min.css">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<root><section><h1>Curves in the plane</h1><h2>Points</h2><p>Currently we are dealing with two-dimensional points so that means that we only have a <mathjax>$x$</mathjax> and <mathjax>$y$</mathjax> component. Later on we will deal with more dimensions.</p><p>If we have two points <mathjax>$P1$</mathjax> and <mathjax>$P2$</mathjax> then we can get a <strong>vector</strong> <em>between</em> those points by subtracting them: <mathjax>$\vec{v} = P2 - P1$</mathjax>. A vector is just a fancy word for the difference between the coordinates of two points.</p><p>For example, if we have <mathjax>$P1$</mathjax> and <mathjax>$P2$</mathjax> as follows:<br/><mathjax>$$\begin{align}
P1 &amp;= (1, 5)\\
P2 &amp;= (3, 8)
\end{align}$$</mathjax></p><p>Then the vector <mathjax>$\vec{v}$</mathjax> would be:<br/><mathjax>$$\begin{align}
\vec{v} &amp;= P1 - P2\\
        &amp;= (2, 3)\\
\end{align}$$</mathjax></p><p>This gives us a <em>vector</em> with a <mathjax>$x$</mathjax> component of <mathjax>$2$</mathjax> and a <mathjax>$y$</mathjax> component of <mathjax>$3$</mathjax>. These components are also often called <mathjax>$dx$</mathjax> and <mathjax>$dy$</mathjax> and their ratio represents the <em>slope</em> of the line between the two points. The slope is basically the direction and steepness of the line.</p><aside><p>Now the tricky thing is that a vector <mathjax>$\vec{v}$</mathjax> and a point <mathjax>$p$</mathjax>j might look exactly the same when written down. There is nothing really wrong with that but when doing calculations it really helps to make sure that you do not mix up your vectors and points in weird ways.</p><p>That is why we put those arrows above vectors to make sure that we don't forget they are not coordinates. Remember: vectors represent a difference, a movement perhaps. A <mathjax>$translation$</mathjax>.</p></aside><p>When reading about slopes of lines it is not uncommon to see the term <em>rise over run</em> which is not at all a bad way to look at it. We can use it to clearly define slope and also show off some more variations on how this ratio might look in the wild. There is no real consensus on whether you should use <mathjax>$d$</mathjax>, <mathjax>$\delta$</mathjax> or <mathjax>$\Delta$</mathjax> but it helps to always think of them as <strong>difference</strong>.</p><aside><p>The letter <mathjax>$d$</mathjax> should be a obvious subsitute for <em>difference</em> but in case you are unfamiliar with <mathjax>$\delta$</mathjax> and <mathjax>$\Delta$</mathjax>, they are just the Greek lowercase and uppercase variant of our roman <mathjax>$d$</mathjax> and <mathjax>$D$</mathjax> respectively.</p><p>In math we tend to be very terse (and also lazy) so we do not want to spend lots of time thinking about sensible names because most of the things we think up are hard to name and nobody understands them anyway. So what we do is just use as many different single letters as we can and when we run out we just turn to other character systems. We can always use subscript and superscript to differentiate stuff as well. In the worst case we can always make up some weird characters of our own with some fancy font and make <em>that</em> a convention.</p></aside><p>It's highly likely that you run into this ratio in the wild so it helps to show the most comment variantions that people use to write it. If you are going to remember one thing, please remember that <em>delta</em> means <em>difference</em> in (scientific) literature.</p><p><mathjax>$$\begin{align}
slope &amp;= \frac{rise}{run} = \frac{y_2 - y_1}{x_2 - x_1}\\
      &amp;= \frac{dy}{dx}\\
      &amp;= \frac{\delta{y}}{\delta{x}}\\
      &amp;= \frac{\Delta{y}}{\Delta{x}}\\
\end{align}$$</mathjax></p><h2>Chaikin's algorithm</h2><p>In this chapter we are going to get familiar with <strong>Chaikin's algorithm</strong>. The algorithm is a <em>very practical</em> way to draw a reasonable curve between any three or more points. In fact, you can in theory have an infinitely long list of points but sadly our machines are not capable of that yet.</p><p>We should not let that stop us though. Chaikin's algorithm is a good place to start and it is incredibly satisfying and fun to play around with as well. Additionally, this will give us a good foundation when we move on to discuss Bézier curves later in this chapter.</p><p>Imagine that we want a machine that can draw a <strong>curve</strong> between a list of points that we give? Since we want it to draw a line we can deduct that we are working int two-dimensional space. Now, we have this plane (flat surface) and a list of points on that plane to work with. We will proceed with the engineering way instead of the mathematical way.</p><aside>This chapter is wholly incomplete but I almost have the content to finish it ready.</aside><h2>Bézier curves</h2><p>In vector graphics, Bézier curves are used to model smooth curves that can scale indefinitely. A Bézier curve is a parametric curve used in computer graphics.</p><aside>The curve, which is related to the Bernstein polynomial, is named after Pierre Bézier, who used it in the 1960s for designing curves for the bodywork of Renault cars.</aside><p>Suppose we have three points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>.</p><p>Referring to the introduction, we can write down a curve <mathjax>$P(t)$</mathjax> between <mathjax>$P_0$</mathjax> and <mathjax>$P_2$</mathjax> and using <mathjax>$P_1$</mathjax> as a <em>control point</em> as follows.</p><p><mathjax>$$\begin{align}
P(t) &amp;= (1-t)\left[(1-t)P_0 + tP_1\right] + t\left[(1-t)P_1 + tP_2\right]\\
     &amp;= (1-t)^{2}P_0 + 2t(1-t)P_1 + t^{2}P_2
\end{align}$$</mathjax></p><p>Now this is starting to become pretty nasty. What would happen if we have a curve with ten control points? We would end up with a pretty nasty polynomial indeed. Those things are also not really CPU friendly if you write them naively. We need a better algorithm to deal with these curves if we want to work with them in <em>a nice way</em>.</p><p>Luckily for us, there's a different way to formalize it. We can also write it as a recursive definition which, as we will see, works much better if we want to translate this into code.</p><p><mathjax>$$P^j_i =
\begin{cases}
(1-t)P^{j-1}_i + tP^{j-1}_{i-1} \quad&amp;\text{if j &gt; 0}\\
P_i &amp;\text{otherwise}
\end{cases}$$</mathjax></p><p>This recursive Bézier definition above is taken straight from the UC Davis Introduction to Computer Graphics course and it makes sense in the context of that course but it is a bit hard to read outside of that context.</p><p>If we look at the recursive definition as given on Wikipedia, things might become a bit easier to understand. Let <mathjax>$B_{{P_0}{P_1}\dots{P_n}}$</mathjax> denote the Bezier curve determined by any selection of points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax>, ... <mathjax>$P_n$</mathjax>.</p><p><mathjax>$$\begin{cases}
B_{P_0}(t) &amp;= P_0\\
      B(t) &amp;= B_{{P_0}{P_1}}\dots{P_n}(t) = (1-t)B_{{P_0}{P_1}\dots{P_n-1}}(t) + tB_{{P_1}{P_2}\dots{P_n}}(t)
\end{cases}$$</mathjax></p><p>This basically says that if the list of points contains only a single point then that point is the answer. Otherwise it depends on a linear interpolation of the same calculation performed on <mathjax>$A$</mathjax> and <mathjax>$B$</mathjax> where <mathjax>$A$</mathjax> is the given list of points except the first and <mathjax>$B$</mathjax> is the given list of points except the last. In this way the algorithm will <em>narrow down</em> on the perfect interpolation using the <em>control points</em> provided. This process will recurse for any <mathjax>$A$</mathjax> and <mathjax>$B$</mathjax> until the list argument will be a singleton list. In that case the function returns on the <mathjax>$B_{P_0}$</mathjax> clause which just returns <mathjax>$P_0$</mathjax> (i.e. the point argument).</p><p>This gives us something a little bit more concrete to work with. To be really explicit, we will use a concrete example.</p><h5>three point example</h5><p>We want to calculate a point <mathjax>$B(t)$</mathjax> on a Bezier curve using the <em>control points</em> <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>. Since this is going to be very useful for the algorithm descriptions that are coming up, we are going to start with re-naming our function <mathjax>$B_{{P_0}{P_1}{P_2}}(t)$</mathjax> so that <mathjax>$B(t) = B_{{P_0}{P_1}{P_2}}(t)$</mathjax>.</p><p>This just means that our <mathjax>$B(t)$</mathjax> function is dealing with the <em>known</em> points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>. You might consider them a <em>hidden</em> (or environmental) parameter of the algorithm.</p><aside><p><mathjax>$B_{{P_0}{P_1}{P_2}}$</mathjax> represents the full Bezier curve (defined by points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>) and <mathjax>$B_{{P_0}{P_1}{P_2}}(t)$</mathjax> refers to any point on the curve where <mathjax>$0\le t\le1$</mathjax>.</p><p>Any <mathjax>$B(t)$</mathjax> function might actually refer to a <mathjax>$B_{{P_0}{P_1}\dots{P_n}}(t)$</mathjax> function but the real set of control points we are dealing with should be clear from context.</p></aside><p>Following the definitions we can say that:<br/><mathjax>$$\begin{align}
B_{{P_0}{P_1}{P_2}}(t) &amp;= (1-t)B_{{P_0}{P_1}}(t) + tB_{{P_1}{P_2}}(t)
\end{align}$$</mathjax></p><p>Which gives us two new terms <mathjax>$B_{{P_0}{P_1}}(t)$</mathjax> and <mathjax>$B_{{P_1}{P_2}}(t)$</mathjax>. We need to keep going and expand those terms until there is nothing left to expand. So, continuing we get:</p><p><mathjax>$$\begin{align}
B_{{P_0}{P_1}}(t) &amp;= (1-t)B_{{P_0}}(t) + tB_{{P_1}}(t)\\
B_{{P_1}{P_2}}(t) &amp;= (1-t)B_{{P_1}}(t) + tB_{{P_2}}(t)\\
\end{align}$$</mathjax></p><p>We know from the introduction that <mathjax>$(1 - t)P_0 + tP_1$</mathjax> is equivalent to a <em>linear interpolation</em> between values <mathjax>$P_0$</mathjax> and <mathjax>$P_1$</mathjax>. If we take a closer look at the example above we can see that in the context of points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>, our final interpolation is actually a linear interpolation of the linear interpolation between <mathjax>$P_0$</mathjax> and <mathjax>$P_1$</mathjax> and the linear interpolation of <mathjax>$P_1$</mathjax> and <mathjax>$P_2$</mathjax>. This makes sense since we already stated the definition would be recursive.</p><h5>five point example</h5><p>In order to make it really clear how the recursion works we will do one more example and in this case we will use five control points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax>, ... <mathjax>$P_4$</mathjax>. We will start with the first recursion which looks like this.</p><p><mathjax>$$\begin{align}
B_{{P_0}{P_1}{P_2}{P_3}{P_4}}(t) = (1-t)B_{{P_0}{P_1}{P_2}{P_3}(t)} + tB_{{P_1}{P_2}{P_3}{P_4}(t)}
\end{align}$$</mathjax></p><p>What we are doing is a <em>divide and conquer</em> algorithm were we split the problem up in two smaller halves. We will keep splitting until we are dealing with single points.</p><p>For the next level we need to calculate both <mathjax>$B_{{P_0}{P_1}{P_2}{P_3}}(t)$</mathjax> and <mathjax>$B_{{P_1}{P_2}{P_3}{P_4}}(t)$</mathjax> that now appear on the right hand side of the expansion above.</p><p><mathjax>$$\begin{align}
B_{{P_0}{P_1}{P_2}{P_3}}(t) &amp;= (1-t)B_{{P_0}{P_1}{P_2}(t)} + tB_{{P_1}{P_2}{P_3}(t)}\\
B_{{P_1}{P_2}{P_3}{P_4}}(t) &amp;= (1-t)B_{{P_1}{P_2}{P_3}(t)} + tB_{{P_2}{P_3}{P_4}(t)}
\end{align}$$</mathjax></p><p>We need to continue until we have <em>singleton</em> lists (lists of only one element) and so far we are down to lists of three elements. We need to do two more recursions.</p><p>We now have three unique terms appearing on the right hand sides of our expansions so we proceed to calculate <mathjax>$B_{{P_0}{P_1}{P_2}}(t)$</mathjax>, <mathjax>$B_{{P_1}{P_2}{P_3}}(t)$</mathjax>and <mathjax>$B_{{P_2}{P_3}{P_4}}(t)$</mathjax>.</p><p><mathjax>$$\begin{align}
B_{{P_0}{P_1}{P_2}}(t) &amp;= (1-t)B_{{P_0}{P_1}(t)} + tB_{{P_1}{P_2}}\\
B_{{P_1}{P_2}{P_3}}(t) &amp;= (1-t)B_{{P_1}{P_2}(t)} + tB_{{P_2}{P_3}}\\
B_{{P_2}{P_3}{P_4}}(t) &amp;= (1-t)B_{{P_2}{P_3}(t)} + tB_{{P_3}{P_4}}
\end{align}$$</mathjax></p><p>And we're almost there. Now we just have the linear interpolations <mathjax>$B_{{P_0}{P_1}(t)}$</mathjax>, <mathjax>$B_{{P_1}{P_2}(t)}$</mathjax>, <mathjax>$B_{{P_2}{P_3}(t)}$</mathjax> and <mathjax>$B_{{P_3}{P_4}(t)}$</mathjax> left.</p><p><mathjax>$$\begin{align}
B_{{P_0}{P_1}}(t) &amp;= (1-t)B_{P_0}(t) + tB_{P_1}\\
B_{{P_1}{P_2}}(t) &amp;= (1-t)B_{P_1}(t) + tB_{P_2}\\
B_{{P_2}{P_3}}(t) &amp;= (1-t)B_{P_2}(t) + tB_{P_3}\\
B_{{P_3}{P_4}}(t) &amp;= (1-t)B_{P_3}(t) + tB_{P_4}\\
\end{align}$$</mathjax></p><p>And since our final recursions all yield <mathjax>$B$</mathjax> functions of singleton lists we are done. Note that in the final recursion we had four unique terms to work with. This makes sense since we started with five control points <mathjax>$P_0$</mathjax>, <mathjax>$P_1$</mathjax>, ... <mathjax>$P_4$</mathjax> in the beginning.</p><p>Now imagine writing out the full expansion of that and you can see how the divide and conquer algorithm is so useful.</p><aside>Would you wanna write out that whole thing manually? It would be kind of easy to do using a computer program though. A nice project would be to create a generator for this code or even just the math. Or create a Bernstein class that can handle <em>any</em> length of control point array.</aside></section></root>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
</body>
</html>
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Multiple Precision Arithmetic</title>
    <link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:500|Raleway" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/arduino-light.min.css">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<root><section><hgroup><h2>Radix <mathjax>$\beta$</mathjax> numbers</h2><h4>Where things get a little bit messy</h4></hgroup><p>In this section we will start using <mathjax>$\beta$</mathjax> instead of <mathjax>$x$</mathjax> in a lot of cases. Without going into much math, there is a real distinction between <mathjax>$P(x)$</mathjax> and <mathjax>$P(\beta)$</mathjax>. The main thing to keep in mind is that when we use <mathjax>$x$</mathjax> we usually don't care too much about the actual value of <mathjax>$x$</mathjax>. However, when we use <mathjax>$\beta$</mathjax> we <strong>do</strong> care about the actual value of <mathjax>$\beta$</mathjax> for reasons that will become soon apparent.</p><p>The only thing we need to do to go from a polynomial to a <em>positional number system</em> is to replace <mathjax>$x$</mathjax> with some value of <mathjax>$\beta$</mathjax> and limit the coefficients to values where <mathjax>$a_i &lt; \beta$</mathjax>. We will also call this value <mathjax>$\beta$</mathjax> the <em>radix</em> or <em>base</em> of the number system.</p><p>Let's start with the familiar decimal system.<br/><mathjax>$$2435 = 2{\beta^3} + 4{\beta^2} + 3{\beta} + 5$$</mathjax></p><p>where <mathjax>$\beta = 10$</mathjax>.</p><p>So far so good since this is exactly like the polynomials from the previous section. However, a strange thing happens when an operation between two coefficients yields a result <mathjax>$c$</mathjax> where <mathjax>$c \le -{\beta}$</mathjax> or where <mathjax>$c \ge {\beta}$</mathjax></p><p><mathjax>$$\begin{align}
P(\beta) &amp;= 5{\beta^0}\\
Q(\beta) &amp;= 5{\beta^0}\\
P(\beta) + Q{\beta} &amp;= 1{\beta^1} + 0{\beta^0}
\end{align}$$</mathjax></p><p>Since our coefficients are limited to values between (but excluding) <mathjax>$-{\beta}$</mathjax> and <mathjax>$\beta$</mathjax> something needs to happen when a result falls outside this range. Hence we get this weird result where suddenly the <em>order</em> of our polynomial changes due to an arithmetic operation.</p></section><section><h4>Modulus</h4><p>We will stay in the decimal system where <mathjax>$\beta = 10$</mathjax> but try to make things a bit more abstract. We start with <em>monomials</em> of the form</p><p><mathjax>$$\begin{align}
P(\beta) &amp;= a_0{\beta^0}\\
Q(\beta) &amp;= b_0{\beta^0}
\end{align}$$</mathjax></p><p>where <mathjax>$-\beta \lt a_i \lt \beta$</mathjax> and <mathjax>$-\beta \lt b_i \lt \beta$</mathjax>.</p><p>Suppose that we are in a weird system where we are limited to monomials. We will also focus on positive coefficients for now (although everything translates naturally to negative coefficients).</p><p>Now what happens when <mathjax>$a_i + b_i \le -\beta$</mathjax> or when <mathjax>$a_i + b_i \ge \beta$</mathjax>? Suppose we have <mathjax>$a_0 = 5$</mathjax> and <mathjax>$b_0 = 5$</mathjax> and we want to calculate</p><p><mathjax>$$\begin{align}
c_0{\beta^0} &amp;= a_0{\beta^0} + b_0{\beta^0}\\
             &amp;= 5{\beta^0} + 5{\beta^0}\\
             &amp;= 0{\beta^0}
\end{align}$$</mathjax></p><p>So what's going on here? Instead of having <mathjax>$10{\beta^0}$</mathjax> like in the case with polynomials we suddenly face the weird fact that when we add up two coefficients <mathjax>$a$</mathjax> and <mathjax>$b$</mathjax> the result equals zero.</p><p>We have been a bit nonchalant in our math. Instead of saying that <mathjax>$c_0{\beta^0} = a_0{\beta^0} + b_0{\beta^0}$</mathjax> we should have said that</p><p><mathjax>$$\begin{align}
c_0{\beta^0} &amp;\equiv a_0{\beta^0} + b_0{\beta^0}\pmod \beta
\end{align}$$</mathjax></p><p>Which meants that <mathjax>$c_0{\beta^0}$</mathjax> and <mathjax>$a_0{\beta^0} + b_0{\beta^0}$</mathjax> are <em>congruent modulo</em> <mathjax>$\beta$</mathjax>.</p><aside><h5>Modular arithmetic</h5><p>The statement <mathjax>$a \equiv b\pmod n$</mathjax> means that <mathjax>$a$</mathjax> and <mathjax>$b$</mathjax> have the same <em>remainder</em> when divided by <mathjax>$n$</mathjax> so that</p><p><mathjax>$$\begin{align}
a &amp;= pn + r\\
b &amp;= qn + r
\end{align}$$</mathjax></p><p>where <mathjax>$0 \le r \lt n$</mathjax> is the common remainder and <mathjax>$n = \beta$</mathjax> in our case.</p><p>The fact that these numbers are congruent modulo <mathjax>$n$</mathjax> (or <mathjax>$\beta$</mathjax>) is something that we enforce and it's a consequence of having our <em>coefficients</em> (the digits in our numbers) be limited to <mathjax>$0 \le d \lt \beta$</mathjax> where <mathjax>$d$</mathjax> is the value of a single coefficient or digit.</p><p>With this restriction, any answer to an operation that might <em>overflow</em> the max (or <em>underflow</em> the min) value will still have to produce a reasonable answer.</p><p>For example</p><p><mathjax>$$\begin{align}
9 &amp;+ 9 \equiv 8\pmod \beta\\
5 &amp;+ 5 \equiv 0\pmod \beta\\
4 &amp;+ 5 \equiv 9\pmod \beta
\end{align}$$</mathjax></p><p>where <mathjax>$\beta = 10$</mathjax>.</p><p>This restriction is necessary because our hardware is limited to numbers of only certain amount of <em>precision</em> (limited by amount of bits in the CPU registers). This means we have to deal with those limits at some point.</p><p>However, our goal is to work with numbers that are so large they don't even fit into the hardware anymore so we will have to deal with a bit of low level computer arithmetic involving the infamous <em>carry</em> value.</p></aside></section><section><hgroup><h4>A different base</h4><h5>Where things get a little bit more messy</h5></hgroup><p>So far we've been seeing a lot of <mathjax>$\beta$</mathjax> and in all of those cases we've been dealing with examples where <mathjax>$\beta = 10$</mathjax> which is a very nice base but a little bit too easy. We need to get comfortable with the fact that <mathjax>$\beta$</mathjax> can be any value of our choosing. And also keep in mind that the algorithms that we desing will work regardless of our <mathjax>$\beta$</mathjax> value.</p><p>Writing our algorithms to cope with any constant <mathjax>$\beta$</mathjax> will not only make them more useful. For example, we can make it run on various kind of hardware just by tweaking the <mathjax>$\beta$</mathjax> value according to the register size of the machine. But it also helps with testing our algorithms since it's easier to force interesting things to happen when <mathjax>$\beta$</mathjax> is small.</p><p>In production we are going to deal with pretty large values of <mathjax>$\beta$</mathjax> but if you want to test your algorithms it quickly becomes a bit messy to deal with these very large numbers so in those cases it helps to limit <mathjax>$\beta$</mathjax> to some small value so they are a bit more friendly to work with. We will see examples of this soon enough.</p><p>Before we continue with the last (but certainly not least) piece of the puzzle we will quickly take a look at a number that is in an unfamiliar base. Let's say that <mathjax>$\beta = 5$</mathjax>. This is a base 5 system.</p><p><asice class="todo">Where am I going with this paragraph?</asice></p><aside><p>From now on, when there might be confusion about the base of a number we will denote it as <mathjax>$a_{\beta}$</mathjax> where <mathjax>$a$</mathjax> is an integer and <mathjax>$\beta$</mathjax> is some kind of base. So when you see</p><p><mathjax>$$2_3 + 2_3 = 11_3 = 4_{10}$$</mathjax></p><p>that means that <mathjax>$2 + 2$</mathjax> equals <mathjax>$11$</mathjax> in base <mathjax>$3$</mathjax> which equals <mathjax>$4$</mathjax> in base <mathjax>$10$</mathjax>. Note that <mathjax>$11_3$</mathjax> is <strong>not equal</strong> to <mathjax>$11_{10}$</mathjax>. If we were to write both numbers as polynomials <mathjax>$P$</mathjax> and <mathjax>$Q$</mathjax> respectively we get</p><p><mathjax>$$\begin{align}
P &amp;= 11_3    = 1\cdot 3 + 1 = 4_{10}\\
Q &amp;= 11_{10} = 1\cdot 10 + 1 = 11_{10}
\end{align}$$</mathjax></p><p>Be careful! We will only use this convention in conjuction with literal integers and only when there might be confusion. When we refer to variables such as <mathjax>$a_i$</mathjax> or <mathjax>$b_i$</mathjax> we will always be referring to the <em>index</em> of the variable and not to the base or radix of its number system. When in doubt, assume a decimal system (i.e. <mathjax>$\beta = 10$</mathjax>). Also note that we might not always be explicitly showing the implicit <mathjax>$\beta$</mathjax> components (but they are always there).</p></aside></section><section><hgroup><h4>The burden of carrying</h4><h5>Where we will fix the final kink</h5></hgroup><p>We have only one issue to deal with before we can wrap this up and start coding. We need to take an look wat what happens when we perform an <em>underflow</em> or <em>overflow</em> operation when we are not limited to working with <em>monomials</em>. This means we need to worry about the <em>carry</em> value and maybe even think back to some grade school arithmetic.</p><p>Suppose we have two polynomials where <mathjax>$\beta$</mathjax> is some kind of value we don't really care about. Except that we have the same restrictions in place as before when dealing with polynomials that have <mathjax>$\beta$</mathjax> variables.</p><aside class="todo">We should probably state these restrictions somewhere more prominently and formally.</aside><p>Let's focus on adding two coefficients first and then we see about the other operations. When we have two coefficients <mathjax>$a_i$</mathjax> and <mathjax>$b_i$</mathjax> we saw earlier that in our <mathjax>$\beta$</mathjax> radix system all the coefficients have to be</p><p><mathjax>$$c_i \equiv (a_i + b_i) \pmod \beta$$</mathjax></p><p>but this still leaves us with the situation when <mathjax>$a_i + b_i \ge \beta$</mathjax>. We need to do something with that overflow.</p><aside><p>An interesting question we can ask ourselves as this point is: what is the max value that we can get from an arithmetic operation involving <mathjax>$a_i$</mathjax> and <mathjax>$b_i$</mathjax>?</p><p>Well, since we're still asuming only zero or positive coefficients we can say that</p><p><mathjax>$$\begin{align}
0 &amp;\le a_i \lt \beta\\
0 &amp;\le b_i \lt \beta\\
0 &amp;\le a_i + b_i \le {2{\beta} - 2}
\end{align}$$</mathjax></p><p>And while we are at it might as well sneak peak into the future. What happens when we perform a multiplication?</p><p><mathjax>$$\begin{align}
0 &amp;\le a_{i}b_{i} \le (\beta - 1)(\beta - 1)\\
0 &amp;\le a_{i}b_{i} \le \beta^2 - 2{\beta} + 1
\end{align}$$</mathjax></p><p>Note the wonderful <mathjax>${\beta^2} - 2{\beta} + 1$</mathjax> polynomial that appears.</p></aside></section></root>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
</body>
</html>